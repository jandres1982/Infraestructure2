#requires -Version 2
<#
        .SYNOPSIS
        Checkscript for a specific test.
        .DESCRIPTION
        This script is based on the MasterCheck.ps1 script.
        The script take a specific check which is definied, and write the result back to the MasterCheck script.

        The following function can be used from the Masterscript MasterCheck.ps1:
        LogWriter (Write in the specified Logfile of the MasterCheck.ps1 script)
        WriteCheckElement (writes the result of this check to the Result file which is defined in the MasterCheck.ps1 script)
                       
        .EXAMPLE
        Functions which are used from MasterCheck...
        LogWriter "my input for the Logfile..." (Add entry with timestamp...)
        LogWriter "my input for the Logfile..." 0 (without timestamp for headers etc...)
        WriteCheckElement -State $true -Info "No more Infomation." -error "Information about the Error if exists." -Area "OS" -ShortDesc "Example" -Desc "Description for the example" -CheckID ChecksciptTemplate

        .NOTES
        Information about the type of the parameters in WriteCheckElement:

        -[boolean]State     ($true | $false)
        If the check is passed then $true else $false (writes additional infos below the error message)
  
        -[string]Info
        Information to the check (optional)
  
        -[string]error
        Important information when the check failed.
        example: -error "<h2>this is the error</h2><ul><li>item 1</li><li>item 2</li><li>item 3</li></ul>"
  
        -[string]Area  
        Defined the area of the checkScript

        -[string]ShortDesc
        Short description of the check    
 
        -[string]Desc
        Detaildescription about the script
 
        -CheckID
        This ist the name of the script and unique
 
        # ######################################################################
        # ScriptName:   CheckAntiVirusSoftware.ps1
        # Description:  Search for existing Anti-Virus Software
        # Created by:   x86 & Cloud Automatisation | Matthias Fankhauser | matthias.fakhauser@swisscom.com
        # CreateDate:   18.01.2016
        #
        # History:
        # Version 1.0   |   18.01.2016 | Matthias Fankhauser | First version
        # Version 1.1   |   18.01.2016 | Matthias Fankhauser | Review
        # ######################################################################
#>
param
(
    [Parameter(Mandatory    = $false)][bool]$Collectinfo = $false                 	# Parameter to collect Scriptinformations   
)

$ScriptVersion = '1.1'      # Version
# #################################### General !!! Do not change !!!##############################
#region General definitions
$CScriptRootFolder     = Split-Path -Parent -Path $MyInvocation.MyCommand.Definition       	# Script RootFolder
$CScriptNameFull       = $MyInvocation.MyCommand.Definition                          	# Full path of this script including scriptname
$CScriptName           = [IO.Path]::GetFileNameWithoutExtension($CScriptNameFull)   	# Only the scriptname without extention
$ThisComputername       = $env:COMPUTERNAME                                           # This computername
$ThisDomain             = $env:USERDNSDOMAIN                                          # This domain
$ThisServerFQDN         = $ThisComputername.ToUpper()                                 # Build FQDN string
If(!($ThisDomain -eq $null))
{
    $ThisServerFQDN     = $ThisComputername + '.' + $ThisDomain
}

# Current username that run this script
$DateTimestamp          = Get-Date -Format 'dd.MM.yyyy HH:mm:ss'                    	# Current date and time
# OS description (name)
#endregion
# ######################################################################

# ----------------------------------------------------------------------------------------------------- 
# ########################## Script Paramenter (Costumized for each script)############################
#region Header Informations
# This items are to define based on the Excelsheet with the Checks.

#CheckArea (Where is this check required)
[bool]$PreCheck 			= $true
[bool]$QCheck 				= $false

#Area
[string]$Area 				= 'Malware'

#Short Descripton of the Script
[string]$ShortDescription 	= 'Anti-Virus' 

#Detaildescripton of the Script
[string]$DetailDescription 	= 'Search installed AntiVirus software' 
 
#Products
[array]$products 			= 'Full' , 'Limited'

#endregion
# ######################################################################
# -----------------------------------------------------------------------------------------------------
 
# ####################### Functions ##########################
#region Functions of the Masterscript !!! Must be on Top of this Script !!!
# #################################################

# Collect informations about this script
function PutScriptInfo ()
{
    CollectScriptInfo -Area $Area -CheckScriptFullPath  $CScriptNameFull -CheckID $CScriptName -products $products -PreCheck $PreCheck -QCheck $QCheck
}
#endregion
# #################################################
 

# ########################## Script static Paramenters !!! Do not change !!! ############################
#region Script static Paramenters
[string]$CheckID			= $CScriptName	# CheckID is the Scriptname
[bool]	$Script:State 				= $false		#State Check
[string]$Script:Information 		= ''			#Additional information
[string]$Script:ErrorInformation 	= ''			#ErrorInformation

# Run only when the argument -Collectinfo is true --> exit
if($Collectinfo)
{
    PutScriptInfo
    exit
}
#endregion
# #######################################################################################################
 
# ########################## Script Paramenter ############################
#region Script specific parameters
$sb = New-Object -TypeName System.Text.StringBuilder      # Create stringbuilder object...
$null = $sb.Clear # Clear stringbuilder object
# ##########################################################################
 
 
# ####################################################################################################### 
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# ++++++++++++++ Here is the section for the Check ++++++++++++++
#
# Required Output of this Script:
# 
# $Script:State = $true | $false (Is the Check OK or not OK)
# $Script:Information = "...." (Aditional Information about the result)
# $Script:ErrorInformation = "Information about non passed check"
#
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
#region checkscript

# Available Antivirus Malware Products
$AvProducts = @(
    'McAfee'
    'Microsoft Security Essentials'
    'Symantec Endpoint Protection'
    'AVG Internet Security'
    'Sophos'
    'Sunbelt'
    'Kaspersky'
    'Trend Micro'
    'BitDefender'
    'Internet Security'
    'Malware'
    'Spyware'
    'F-Secure'
    'Micropoint'
    'Lavasoft'
    'Avast'
    'Avira'
    'Ashampoo'
    'G DATA'
)

# Join to Line separated with |
$SearchVendors = $AvProducts -join '|'

# Uninstall Software Hive
$regpath32 = 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*'
[Array]$32BitSoftware = (Get-ItemProperty -Path $regpath32) | Select-Object -Property *

# Wow64 Uninstall Software Hive
$regpath64 = 'HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*'
[Array]$64BitSoftware = (Get-ItemProperty -Path $regpath64) | Select-Object -Property *

# Get Software from WMI win32_product
[Array]$Software = Get-WmiObject -Class Win32_Product |
Where-Object -FilterScript {
    $_.Name -match $SearchVendors
} |
Sort-Object -Property Name

# Define Arrays
[Array]$Script:Found32BitSoftware = @()
[Array]$Script:Found64BitSoftware = @()
[Array]$Script:FoundUnderInstalledSoftware = @()

# Function to get values from Registry Uninstall key's
function Get-ValuesFromUninstallKeys
{
    [CmdletBinding()]
    <#
            .SYNOPSIS
            Find and return found Items
            .DESCRIPTION
            Return the found Items
            .EXAMPLE
            Get-ValuesFromUninstallKeys (Array with objects)
    #>
    
    Param
    (
        [Parameter(Mandatory = $true)] [Object]$Uninstallkeys,
        [Parameter(Mandatory = $true)] [string]$SaveToArray
    )
    
    Begin
    {
        foreach($RegItem in $Uninstallkeys)
        {
            If($RegItem.DisplayName -match $SearchVendors)
            {
                $name = $RegItem.DisplayName
                $version = $RegItem.DisplayVersion
                $Vendor = $RegItem.Publisher

                if($RegItem.InstallDate.Length -eq 8)
                {
                    $InstallDate = [DateTime]::Parse($RegItem.InstallDate.Substring(0,4) + '.' + $RegItem.InstallDate.Substring(4,2) + '.' + $RegItem.InstallDate.Substring(6,2)).ToString('dd.MM.yyyy')
                }
                else
                {
                    $InstallDate = ' --- '
                }
                
                Add-PSObject -ArrayFound $SaveToArray -Vendor $Vendor -SoftName $name -SoftVersion $version -SoftInstallDate $InstallDate
            } 
        }
    }
}

# Function to create a PSObject
function Add-PSObject
{
    [CmdletBinding()]
    <#
            .SYNOPSIS
            Create PSObject
            .DESCRIPTION
            Create PsObject with found objects
    #>
    
    Param
    (
        [Parameter(Mandatory = $true)] [string]$Vendor,
        [Parameter(Mandatory = $true)] [string]$SoftName,
        [Parameter(Mandatory = $true)] [string]$SoftVersion,
        [Parameter(Mandatory = $true)] [string]$SoftInstallDate,
        [Parameter(Mandatory = $true)] [string]$ArrayFound
    )
    
    Begin
    {
        # Create PsObject from PatchItem    
        $PsItem = New-Object -TypeName PSObject -Property @{
            Vendor      = $Vendor
            Name        = $SoftName
            Version     = $SoftVersion
            InstallDate = $SoftInstallDate
        }
    
        if($ArrayFound -eq 'UI32') 
        {
            $Script:Found32BitSoftware += $PsItem
        }
        elseif($ArrayFound -eq 'UI64')
        {
            $Script:Found64BitSoftware += $PsItem
        }
        else
        {
            $Script:FoundUnderInstalledSoftware += $PsItem
        }
        
        # CleanUP
        $Vendor = ''
        $SoftName = ''
        $SoftVersion = ''
        $SoftInstallDate = ''
        
    }
}

# Function to get Software via WMI Provider 
function Get-SoftwareWMI
{
    <#
            .SYNOPSIS
            Get Software with WMI
            .DESCRIPTION
            Get Software from WMI
    #>
    
    foreach($SoftwareItem in $Software)
    {
        If($SoftwareItem.Name -match $SearchVendors)
        {
            $wmiName = $SoftwareItem.Name
            $wmiVendor = $SoftwareItem.Vendor
            $wmiVersion = $SoftwareItem.Version
            
            if($SoftwareItem.InstallDate.Length -eq 8)
            {
                $wmiInstallDate = [DateTime]::Parse($SoftwareItem.InstallDate.Substring(0,4) + '.' + $SoftwareItem.InstallDate.Substring(4,2) + '.' + $SoftwareItem.InstallDate.Substring(6,2)).ToString('dd.MM.yyyy')
            }
            else
            {
                $wmiInstallDate = ' --- '
            }            
            # Create PSObject
            Add-PSObject -ArrayFound 'WMIStore' -Vendor $wmiVendor -SoftName $wmiName -SoftVersion $wmiVersion -SoftInstallDate $wmiInstallDate
            
            # CleanUP
            $wmiName = ''
            $wmiVendor = ''
            $wmiVersion = ''
            $wmiInstallDate = ''
        }
    }
}

function Confirm-AntiVirusState
{
    <#
            .SYNOPSIS
            Short Description
            .DESCRIPTION
            Detailed Description
            .EXAMPLE
            Confirm-AntiVirusState
            explains how to use the command
            can be multiple lines
            .EXAMPLE
            Confirm-AntiVirusState
            another example
            can have as many examples as you like
    #>
    # Generate Results
    Begin
    {
        If($Found32BitSoftware.Count + $Found64BitSoftware.Count + $FoundUnderInstalledSoftware.Count -ne 0)
        {
            $Script:State = $false
        
            if([int]$Found32BitSoftware.Count -gt 0)
            {
                $null = $sb.AppendLine("<p><b>Found in Registry $regpath32</b></p>")
                $null = $sb.AppendLine("<table class=`"infotable`">")
                $null = $sb.AppendLine('<thead><tr><th>Vendor:</th><th>Name:</th><th>Version:</th><th>Install date:</th></tr></thead>')
                $null = $sb.AppendLine('<tbody>')
            
                for ($i = 0; $i -lt $Script:Found32BitSoftware.Count; $i ++)
                {
                    $v = $Script:Found32BitSoftware[$i].Vendor
                    $n = $Script:Found32BitSoftware[$i].Name
                    $ver = $Script:Found32BitSoftware[$i].Version
                    $id = $Script:Found32BitSoftware[$i].InstallDate
                
                    $null = $sb.AppendLine("<tr><td>$v</td><td>$n</td><td>$ver</td><td>$id</td></tr>")
                }
                $null = $sb.AppendLine('</tbody></table></br>')
            }
        
            if($Found64BitSoftware.Count -gt 0)
            {
                $null = $sb.AppendLine("<p><b>Found in Registry $regpath64</b></p>")
                $null = $sb.AppendLine("<table class=`"infotable`">")
                $null = $sb.AppendLine('<thead><tr><th>Vendor:</th><th>Name:</th><th>Version:</th><th>Install date:</th></tr></thead>')
                $null = $sb.AppendLine('<tbody>')
            
                for ($i = 0; $i -lt $Script:Found64BitSoftware.Count; $i ++)
                {
                    $v = $Script:Found64BitSoftware[$i].Vendor
                    $n = $Script:Found64BitSoftware[$i].Name
                    $ver = $Script:Found64BitSoftware[$i].Version
                    $id = $Script:Found64BitSoftware[$i].InstallDate
                
                    $null = $sb.AppendLine("<tr><td>$v</td><td>$n</td><td>$ver</td><td>$id</td></tr>")
                }
                $null = $sb.AppendLine('</tbody></table></br>')
            }
        
            if($Script:FoundUnderInstalledSoftware.Count -gt 0)
            {
                $null = $sb.AppendLine('<p><b>Found in installed software</b></p>')
                $null = $sb.AppendLine("<table class=`"infotable`">")
                $null = $sb.AppendLine('<thead><tr><th>Vendor:</th><th>Name:</th><th>Version:</th><th>Install date:</th></tr></thead>')
                $null = $sb.AppendLine('<tbody>')
            
                for ($i = 0; $i -lt $Script:FoundUnderInstalledSoftware.Count; $i ++)
                {
                    $v = $Script:FoundUnderInstalledSoftware[$i].Vendor
                    $n = $Script:FoundUnderInstalledSoftware[$i].Name
                    $ver = $Script:FoundUnderInstalledSoftware[$i].Version
                    $id = $Script:FoundUnderInstalledSoftware[$i].InstallDate
                
                    $null = $sb.AppendLine("<tr><td>$v</td><td>$n</td><td>$ver</td><td>$id</td></tr>")
                }
                $null = $sb.AppendLine('</tbody></table></br>')
            }
            $Script:Information = ' --- '
            $Script:ErrorInformation = $sb.ToString()
        }
        else
        {
            $Script:State = $true
            $Script:Information 		= 'No Anti-virus software found'
            $Script:ErrorInformation = ' --- '
        }
    }
}

# Query WMI
Get-SoftwareWMI
# Query Uninstall 32
Get-ValuesFromUninstallKeys -Uninstallkeys ($32BitSoftware) -SaveToArray  'UI32'
# Query Uninstall 64
Get-ValuesFromUninstallKeys -Uninstallkeys ($64BitSoftware) -SaveToArray 'UI64'
# Confirm AntivirusState
Confirm-AntiVirusState

#endregion
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  
# ########################## Push the result to the masterScript ############################ 
#region Push result
WriteCheckElement -State $State -Info $Information -error $ErrorInformation -Area $Area -ShortDesc $ShortDescription -Desc $DetailDescription -CheckID $CheckID
#endregion  